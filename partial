def classify_partial_journeys(mo_whole):
    df = mo_whole.copy()

    # Step 1: sort for consistency
    df = df.sort_values(by=['imo', 'departuredate', 'arrivaldate'])

    # Group by IMO
    results = []
    for imo, group in df.groupby('imo'):
        temp = group.copy()

        # Find duplicates
        dep_counts = temp['departuredate'].value_counts()
        arr_counts = temp['arrivaldate'].value_counts()

        dep_map = temp['departuredate'].map(dep_counts)
        arr_map = temp['arrivaldate'].map(arr_counts)

        temp['partial_journey'] = 'no'

        # Tag load & discharge
        temp.loc[(dep_map > 1) & (arr_map == 1), 'partial_journey'] = 'load'
        temp.loc[(arr_map > 1) & (dep_map == 1), 'partial_journey'] = 'discharge'

        # Tag both where overlaps happen
        load_discharge = temp[temp['partial_journey'].isin(['load', 'discharge'])]
        for i, row in load_discharge.iterrows():
            overlaps = load_discharge[
                (load_discharge['departuredate'] <= row['arrivaldate']) &
                (load_discharge['arrivaldate'] >= row['departuredate'])
            ]
            if len(overlaps) > 1:
                temp.loc[overlaps.index, 'partial_journey'] = 'both'

        # Create 'partial' column
        temp['partial'] = 'no'
        for val in ['load', 'discharge', 'both']:
            part_rows = temp[temp['partial_journey'] == val]
            if not part_rows.empty:
                temp.loc[part_rows.index[0], 'partial'] = 'yes'
                temp.loc[part_rows.index[1:], 'partial'] = 'dup'

        results.append(temp)

    final_df = pd.concat(results).sort_index()
    return final_df
