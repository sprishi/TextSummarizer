def analyze_vessel_journeys(mo_whole: pd.DataFrame) -> pd.DataFrame:
    """
    Analyzes vessel journeys to group them by overlap and classify them as
    partial load, discharge, both, or no. Also adds a helper column to
    identify unique partial journeys.

    Args:
        mo_whole: DataFrame with vessel flow data, including 'imo',
                  'departuredate', and 'arrivaldate'.

    Returns:
        A new DataFrame with 'journey_group', 'partial_journey', and 'partial' columns.
    """
    # --- Step 1: Group Overlapping Journeys ---
    df = mo_whole.copy()
    df['departuredate'] = pd.to_datetime(df['departuredate'])
    df['arrivaldate'] = pd.to_datetime(df['arrivaldate'])
    df = df.sort_values(['imo', 'departuredate']).reset_index(drop=True)
    df['journey_group'] = None

    for imo, group in df.groupby('imo'):
        if len(group) < 2:
            df.loc[group.index, 'journey_group'] = f"{imo}_1"
            continue

        G = nx.Graph()
        indices = group.index.tolist()
        G.add_nodes_from(indices)

        for i in range(len(indices)):
            for j in range(i + 1, len(indices)):
                idx1, idx2 = indices[i], indices[j]
                is_overlapping = (df.loc[idx1, 'departuredate'] <= df.loc[idx2, 'arrivaldate'] and
                                  df.loc[idx1, 'arrivaldate'] >= df.loc[idx2, 'departuredate'])
                if is_overlapping:
                    G.add_edge(idx1, idx2)

        for i, cluster in enumerate(nx.connected_components(G), 1):
            df.loc[list(cluster), 'journey_group'] = f"{imo}_{i}"

    # --- Step 2: Classify Journey Groups and Add Partial Column ---
    df['partial_journey'] = 'no' # Default value

    # Group by the newly created journey_group to classify each
    for name, group in df.groupby('journey_group'):
        # A group with only one row is not a partial journey
        if len(group) <= 1:
            df.loc[group.index, 'partial_journey'] = 'no'
            continue

        # Count unique departure and arrival dates within the group
        unique_departures = group['departuredate'].nunique()
        unique_arrivals = group['arrivaldate'].nunique()

        # Classify the journey type based on the counts
        if unique_departures > 1 and unique_arrivals == 1:
            df.loc[group.index, 'partial_journey'] = 'load'
        elif unique_departures == 1 and unique_arrivals > 1:
            df.loc[group.index, 'partial_journey'] = 'discharge'
        elif unique_departures > 1 and unique_arrivals > 1:
            df.loc[group.index, 'partial_journey'] = 'both'
        else: # unique_departures == 1 and unique_arrivals == 1
            df.loc[group.index, 'partial_journey'] = 'no'


    # --- Step 3: Assign 'yes', 'dup', or 'no' to the 'partial' column ---
    # Default to 'no'
    df['partial'] = 'no'

    # Get indices of all rows that are part of a partial journey
    partial_indices = df[df['partial_journey'] != 'no'].index

    # Identify the first row in each journey_group
    is_first_in_group = ~df.loc[partial_indices].duplicated(subset=['journey_group'], keep='first')

    # Assign 'yes' to the first row and 'dup' to subsequent rows
    df.loc[partial_indices, 'partial'] = np.where(is_first_in_group, 'yes', 'dup')

    return df
