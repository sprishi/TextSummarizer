# Assuming df is your entire dataset and df_new is your unseen data
df_combined = pd.concat([df, df_new])

# Function to get the top countries for each flight
def get_top_countries(group):
    top_countries = group['load_country'].value_counts().index.tolist()
    next_idx = group.index[-1] + 1
    if next_idx in df_combined.index:  # Check if there's a next row
        for i in range(5):
            if i < len(top_countries):
                df_combined.at[next_idx, f'top_country_{i+1}'] = top_countries[i]
            else:
                df_combined.at[next_idx, f'top_country_{i+1}'] = None

df_combined.groupby('no').apply(get_top_countries)





---------------

import numpy as np
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Masking
from sklearn.metrics import accuracy_score, f1_score

# Prepare sequences
X_list = []
y_list = []

for flight_no in X_train['no'].unique():
    flight_data = X_train[X_train['no'] == flight_no]
    X_list.append(flight_data.drop('no', axis=1).values)  # assuming 'no' is the flight number column
    y_list.append(y_train.loc[flight_data.index])

# Padding sequences
X_padded = tf.keras.preprocessing.sequence.pad_sequences(X_list, padding='post', dtype='float32')
y_padded = tf.keras.preprocessing.sequence.pad_sequences(y_list, padding='post', dtype='int32')

# Define LSTM model
model = Sequential()
model.add(Masking(mask_value=0., input_shape=(X_padded.shape[1], X_padded.shape[2])))  # Masking layer for padded values
model.add(LSTM(50, return_sequences=True))
model.add(LSTM(50))
model.add(Dense(len(np.unique(y_encoded)), activation='softmax'))
model.compile(loss='sparse_categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

# Train model
model.fit(X_padded, y_padded, epochs=50, batch_size=32, verbose=1)

# Prediction and Evaluation
y_pred = model.predict(X_padded)
y_pred_classes = np.argmax(y_pred, axis=1)

print("Accuracy:", accuracy_score(y_padded, y_pred_classes))
print("F1 Score:", f1_score(y_padded, y_pred_classes, average='macro'))

